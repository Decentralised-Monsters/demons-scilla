scilla_version 0

import BoolUtils

library AuctionFactoryLib

(* Error events *)
type Error =
| CodeNotContractOwner
| CodeBlockGap
| CodeNotStartedYet
| CodeAlreadyCanceled
| CodeTimeOut
| CodeIsOwner
| CodeBipLessThanCurrent
| CodeNotFound
| CodeNotEndedOrCanceled
| CodeOnlyWithdrawn
| CodeNotTokenOwner

(* custom ADT owner, bidIncrement, startBlock, endBlock, tokenID *)
type StaticAuction =
  | StaticAuction of ByStr20 Uint128 BNum BNum Uint256

(* custom ADT canceled, highestBindingBid, highestBidder, ownerHasWithdrawn, static *)
type Auction =
  | Auction of Bool Uint128 ByStr20 Bool StaticAuction

type Operation =
  | Add
  | Sub

let zero_address = 0x0000000000000000000000000000000000000000

let zero256 = Uint256 0
let zero128 = Uint128 0
let zero64 = Uint64 0

let one_hundred128 = Uint128 100
let one256 = Uint256 1
let one64 = Uint64 1
let ff = False

let add_operation = Add
let sub_operation = Sub

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let blk_gte =
  fun (blk1 : BNum) =>
  fun (blk2 : BNum) =>
    let lt = builtin blt blk1 blk2 in
      negb lt

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotContractOwner   => Int32 -1
      | CodeBlockGap           => Int32 -2
      | CodeNotStartedYet      => Int32 -3
      | CodeAlreadyCanceled    => Int32 -4
      | CodeTimeOut            => Int32 -5
      | CodeBipLessThanCurrent => Int32 -6
      | CodeNotFound           => Int32 -7
      | CodeIsOwner            => Int32 -8
      | CodeNotEndedOrCanceled => Int32 -9
      | CodeOnlyWithdrawn      => Int32 -10
      | CodeNotTokenOwner      => Int32 -11
      end
    in
    { _exception : "Error"; code : result_code }

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_uint128 = @option_value Uint128
let option_uint64 = @option_value Uint64
let option_address = @option_value ByStr20

let new_counter =
    fun (current: Uint64) =>
    fun (op: Operation) =>
      match op with
      | Add => builtin add one64 current
      | Sub => builtin sub current one64
      end

let auction_build =
  fun (owner: ByStr20) =>
  fun (increment: Uint128) =>
  fun (min_price: Uint128) =>
  fun (start_block: BNum) =>
  fun (end_block: BNum) =>
  fun (token_id: Uint256) =>
    let s = StaticAuction
      owner
      increment
      start_block
      end_block
      token_id
    in
      Auction ff min_price owner ff s

let min = 
  fun (a: Uint128) =>
  fun (b: Uint128) =>
    let is_less = builtin lt a b in
      match is_less with
      | True => a
      | False => b
      end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract AuctionFactory
(
  contract_owner: ByStr20,
  wallet: ByStr20,
  dmz: ByStr20,
  main: ByStr20 with contract
    field token_owners: Map Uint256 ByStr20
  end
)

(* Mutable fields *)
field funds_by_bidder: Map ByStr20 (Map Uint256 Uint128) 
  = Emp ByStr20 (Map Uint256 Uint128)

field auctions: Map Uint256 Auction = Emp Uint256 Auction
field bid_count: Map Uint256 Uint64 = Emp Uint256 Uint64
field total: Uint256 = zero256
field commission: Uint128 = Uint128 10

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure EmitBidEvent(highest_binding_bid: Uint128, highest_bidder: ByStr20)
  e = {
    _eventname: "BidEventSuccess";
    highest_binding_bid: highest_binding_bid;
    highest_bidder: highest_bidder
  };
  event e
end

procedure OnlyWithdrawn(owner_has_withdrawn: Bool)
  match owner_has_withdrawn with
  | True =>
  | False =>
    err = CodeOnlyWithdrawn;
    ThrowError err
  end
end

procedure OnlyOwner(owner: ByStr20)
  is_owner = builtin eq _sender owner;

  match is_owner with
  | True =>
  | False =>
    err = CodeIsOwner;
    ThrowError err
  end
end

procedure OnlyAfterStart(start_block: BNum, current: BNum)
  is_less = builtin blt current start_block;

  match is_less with
  | True =>
    err = CodeNotStartedYet;
    ThrowError err
  | False =>
  end
end

procedure OnlyBeforeEnd(end_block: BNum, current: BNum)
  is_less = builtin blt end_block current;

  match is_less with
  | True =>
    err = CodeTimeOut;
    ThrowError err
  | False =>
  end
end

procedure OnlyEndedOrCanceled(canceled: Bool, end_block: BNum, current: BNum)
  not_ended = builtin blt current end_block;
  not_canceled = negb canceled;
  active = andb not_ended not_canceled;

  match active with
  | True =>
    err = CodeNotEndedOrCanceled;
    ThrowError err
  | False =>
    (* active = not ended and not canceled *)
  end
end

procedure OnlyNotCanceled(canceled: Bool)
  match canceled with
  | True =>
    err = CodeAlreadyCanceled;
    ThrowError err
  | False =>
  end
end

procedure OnlyNotOwner(owner: ByStr20)
  is_owner = builtin eq _sender owner;

  match is_owner with
  | True =>
    err = CodeIsOwner;
    ThrowError err
  | False =>
  end
end

procedure CheckBipAmount(bid: Uint128, highest_binding_bid: Uint128)
  is_gt_current_highest = builtin lt highest_binding_bid bid;

  match is_gt_current_highest with
  | True =>
  | False =>
    (* if the user isn't even willing to overbid the highest binding bid, there's nothing for us *)
    (* to do except revert the transaction. *)
    err = CodeBipLessThanCurrent;
    ThrowError err
  end
end

procedure CheckStartBlock(start_block: BNum, end_block: BNum, current_block: BNum)
  is_incorect = blk_gte start_block end_block;
  is_less = builtin blt start_block current_block;
  is_error = orb is_incorect is_less;

  match is_error with
  | True =>
    err = CodeBlockGap;
    ThrowError err
  | False =>
  end
end


procedure CheckTokenOwner(token_id: Uint256)
  some_token_owner <-& main.token_owners[token_id];
  dragon_owner = option_address zero_address some_token_owner;
  is_address_call = builtin eq _sender dragon_owner;
  match is_address_call with
  | False =>
    err = CodeNotTokenOwner;
    ThrowError err
  | True =>
  end
end


procedure UpdateCounter(id: Uint256, op: Operation)
  some_bid_count <- bid_count[id];

  current_count_bid = option_uint64 zero64 some_bid_count;
  new_counter = new_counter current_count_bid op;
  is_zero = builtin eq new_counter zero64;

  match is_zero with
  | True =>
    delete bid_count[id];
    delete auctions[id]
  | False =>
    bid_count[id] := new_counter
  end
end

procedure CallTransferFromDMZ(amount: Uint128, from: ByStr20, to: ByStr20)
  is_zero = builtin eq amount zero128;
  match is_zero with
  | True =>
  | False =>
    call_transfer_from = {
      _tag: "TransferFrom";
      _recipient: dmz;
      _amount: Uint128 0;
      from: from;
      to: to;
      amount: amount
    };
    msgs = one_msg call_transfer_from;
    send msgs
  end
end

procedure CallTransferDMZ(to: ByStr20, amount: Uint128)
  is_zero = builtin eq amount zero128;
  match is_zero with
  | True =>
  | False =>
    msg_transfer = {
      _tag: "Transfer";
      _recipient: dmz;
      _amount: zero128;
      to: to;
      amount: amount
    };
    msgs = one_msg msg_transfer;
    send msgs
  end
end

procedure ReturnFunds(id: Uint256, to: ByStr20)
  some_amount <- funds_by_bidder[to][id];

  match some_amount with
  | Some amount =>
    delete funds_by_bidder[to][id];
    CallTransferDMZ to amount
  | None =>
  end
end

procedure TransferFromNFT(to: ByStr20, token_id: Uint256)
  transfered = {
    _tag: "TransferFrom";
    _recipient: main;
    _amount: Uint128 0;
    to: to;
    token_id: token_id
  };
  msgs = one_msg transfered;
  send msgs
end

procedure TransferNFT(to: ByStr20, token_id: Uint256)
  transfered = {
    _tag: "Transfer";
    _recipient: main;
    _amount: Uint128 0;
    to: to;
    token_id: token_id
  };
  msgs = one_msg transfered;
  send msgs
end

(* @dev Put up a card for auction listing *)
(* @param bid_increment: Min increment for each bid *)
(* @param min_price: Starting bid price *)
(* @param start_block: Block number at which the auction should begin *)
(* @param end_block: Block number at which the auction should end *)
(* @param token_id: Token/Card put up for listing *)
transition CreateAuction(bid_increment: Uint128, min_price: Uint128, start_block: BNum, end_block: BNum, token_id: Uint256)
  CheckTokenOwner token_id;

  current_block <-& BLOCKNUMBER;
  total_ids <- total;

  CheckStartBlock start_block end_block current_block;

  next_id = builtin add total_ids one256;
  new_auction = auction_build
    _sender
    bid_increment
    min_price
    start_block
    end_block
    token_id;

  auctions[next_id] := new_auction;
  total := next_id;
  bid_count[next_id] := one64;

  TransferFromNFT _this_address token_id;

  e = {
    _eventname: "AuctionCreated";
    owner: _sender;
    auction: new_auction
  };
  event e
end

(* @dev Bid on an auction listing. DMZ are locked up until Withdraw() is invoked *)
(* @param id: Auction id *)
(* @param amount: Bid amount (DMZ amount); if _sender is the first time bidding on this card, the bid amount is the ENTIRE amount *)
(* If _sender has bidded before, then _sender has intention to raise his/her previous bid
(* bid amount becomes the DIFFERENCE of _sender's previous bid and current bid *)
transition PlaceBid(id: Uint256, amount: Uint128)
  current_block <-& BLOCKNUMBER;
  some_current_bid <- funds_by_bidder[_sender][id];
  some_auction <- auctions[id];
  (* calculate the user's total bid based on the current amount they've sent to the contract *)
  (* plus whatever has been sent with this transaction *)
  current_bid = option_uint128 zero128 some_current_bid;
  new_bid = builtin add current_bid amount;

  match some_auction with
  | Some auction =>
    match auction with
    | Auction canceled highest_binding_bid highest_bidder owner_has_withdrawn static =>
      OnlyNotCanceled canceled;
      (* grab the previous highest bid (before updating fundsByBidder, in case _sender is the *)
      (* highestBidder and is just increasing their maximum bid). *)
      some_highest_bid <- funds_by_bidder[highest_bidder][id];
      highest_bid = option_uint128 zero128 some_highest_bid;

      (* the highest bid might be zero if this listing is the first time that someone has bid *)
      (* funds_by_bidder[highest_bidder] would return 0 *)
      is_highest_bid_zero = builtin eq highest_bid zero128;

      match static with
      | StaticAuction owner bid_increment start_block end_block token_id =>
        OnlyAfterStart start_block current_block;
        OnlyBeforeEnd end_block current_block;
        OnlyNotOwner owner;
        CheckBipAmount new_bid highest_binding_bid;

        (* update bid count only after checks *)
        match some_current_bid with
        | Some current_bid =>
        | None =>
          UpdateCounter id add_operation
        end;

        (* transfer the required dmz to this contract *)
        CallTransferFromDMZ amount _sender _this_address;

        (* if the user has overbid the highestBindingBid but not the highestBid, we simply *)
        (* increase the highestBindingBid and leave highestBidder alone. *)
        (* note that this case is impossible if _sender == highestBidder because you can never *)
        (* bid less DMZ than you've already bid. *)
        is_less = builtin lt new_bid highest_bid;
        is_eq = builtin eq new_bid highest_bid;
        is_raise_self_bid = orb is_less is_eq;
        funds_by_bidder[_sender][id] := new_bid;

        match is_highest_bid_zero with
        | True =>
          (* no existings bids *)
          (* set the bidder as the highest bidder and highest bid *)
          new_highest_binding_bid = new_bid;
          new_auction = Auction canceled new_highest_binding_bid _sender owner_has_withdrawn static;
          auctions[id] := new_auction;
          EmitBidEvent new_highest_binding_bid _sender
        | False =>
          (* listing has existing bids *)
          match is_raise_self_bid with
          | True =>
            (* user has bid less than highest bid *)
            (* if the user has overbid the highestBindingBid but not the highestBid, we simply *)
            (* increase the highestBindingBid and leave highestBidder alone. *)
            (* note that this case is impossible if _sender == highestBidder because you can never *)
            (* bid less DMZ than you've already bid. *)
            new_highest_binding_bid = builtin add new_bid bid_increment;
            new_highest_binding_bid = min new_highest_binding_bid highest_bid;
            new_auction = Auction canceled new_highest_binding_bid highest_bidder owner_has_withdrawn static;
            auctions[id] := new_auction;
            EmitBidEvent new_highest_binding_bid highest_bidder
          | False =>
            (* user has bid more than highest bid *)
            (* set user as the new highestBidder and recalculate highestBindingBid. *)
            new_highest_binding_bid = builtin add highest_bid bid_increment;
            new_highest_binding_bid = min new_bid new_highest_binding_bid;
            new_auction = Auction canceled new_highest_binding_bid _sender owner_has_withdrawn static;
            auctions[id] := new_auction;
            EmitBidEvent new_highest_binding_bid _sender
          end
        end
      end
    end
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

transition CancelAuction(id: Uint256)
  current_block <-& BLOCKNUMBER;
  some_auction <- auctions[id];

  match some_auction with
  | Some auction =>
    match auction with
    | Auction canceled highest_binding_bid highest_bidder owner_has_withdrawn static =>
      OnlyNotCanceled canceled;
      match static with
      | StaticAuction owner bid_increment start_block end_block token_id =>
        OnlyOwner owner;
        OnlyBeforeEnd end_block current_block;

        new_canceled = True;
        new_auction = Auction new_canceled highest_binding_bid highest_bidder owner_has_withdrawn static;
        auctions[id] := new_auction;
        UpdateCounter id sub_operation;
        TransferNFT _sender token_id;
        e = {
          _eventname: "CanceledEventSuccess";
          id: id
        };
        event e
      end
    end
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

transition Withdraw(id: Uint256)
  current_block <-& BLOCKNUMBER;
  some_auction <- auctions[id];
  dev_commission <- commission;

  match some_auction with
  | Some auction =>
    match auction with
    | Auction canceled highest_binding_bid highest_bidder owner_has_withdrawn static =>
      match static with
      | StaticAuction owner bid_increment start_block end_block token_id =>
        OnlyEndedOrCanceled canceled end_block current_block;

        is_highest_bidder = builtin eq highest_bidder _sender;
        is_owner = builtin eq owner _sender;
        UpdateCounter id sub_operation;

        match is_owner with
        | True =>
          match is_highest_bidder with
          | True =>
            err = CodeIsOwner;
            ThrowError err
          | False =>
            some_bid_amount <- funds_by_bidder[highest_bidder][id];
            (* the auction's owner should be allowed to withdraw the highestBindingBid *)
            new_owner_has_withdrawn = True;
            new_auction = Auction canceled highest_binding_bid highest_bidder new_owner_has_withdrawn static;
            auctions[id] := new_auction;

            amount = option_uint128 zero128 some_bid_amount;
            com = builtin mul dev_commission amount;
            com = builtin div com one_hundred128;
            value = builtin sub amount com;

            delete funds_by_bidder[highest_bidder][id];

            CallTransferDMZ owner value;
            CallTransferDMZ wallet com
          end
        | False =>
          match canceled with
          | True =>
            (* if the auction was canceled, everyone should simply be allowed to withdraw their funds *)
            ReturnFunds id _sender
          | False =>
            match is_highest_bidder with
            | True =>
              (* the highest bidder should only be allowed to withdraw the NFT token. *)
              TransferNFT _sender token_id
            | False =>
              (* anyone who participated but did not win the auction should be allowed to withdraw *)
              (* the full amount of their funds *)
              delete funds_by_bidder[_sender][id];
              ReturnFunds id _sender
            end
          end
        end
      end
    end
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

transition SetCommission(value: Uint128)
  IsContractOwner;

  commission := value;

  e = {
    _eventname: "SetCommissionSuccess";
    new_commission: value
  };
  event e
end


(*Empty callbacks*)
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
