scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils IntUtils ListUtils

library DMZClaimLib

(* Error events *)
type Error =
  | CodeNotContractOwner
  | CodeNotFound
  | CodeNotCrowdSale
  | CodeTokenHolderAlreadyExists
  | CodeNotTokenOwner
  | CodeInputOutOfRange
  | CodeMinLvl

let zero256 = Uint256 0
let zero128 = Uint128 0
let zero32 = Uint32 0
let zeroBN = BNum 0
let zero_address = 0x0000000000000000000000000000000000000000
let one_hundred32 = Uint32 100

let one_msg = 
  fun (msg: Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotContractOwner             => Int32 -1
      | CodeNotFound                     => Int32 -2
      | CodeNotCrowdSale                 => Int32 -3
      | CodeTokenHolderAlreadyExists     => Int32 -4
      | CodeNotTokenOwner                => Int32 -5
      | CodeInputOutOfRange              => Int32 -6
      | CodeMinLvl                       => Int32 -7
      end
    in
    { _exception : "Error"; code : result_code }

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_uint128 = @option_value Uint128
let option_uint32 = @option_value Uint32

let get_claim_value =
  fun (current_block: Int256) =>
  fun (acumulated_block: Int256) =>
  fun (rewards: Uint128) =>
    let blocks = builtin sub current_block acumulated_block in
    let some_block128 = builtin to_uint128 blocks in
    let block128 = option_uint128 zero128 some_block128 in
      builtin mul block128 rewards


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract DMZClaimContract
(
  contract_owner: ByStr20,
  init_dmz: ByStr20,
  main: ByStr20 with contract
    field token_lvl: Map Uint256 Uint32,
    field token_owners: Map Uint256 ByStr20
  end
)

(* Mutable fields *)
field dmz: ByStr20 = init_dmz
field min_lvl_for_claim: Uint32 = Uint32 2

(* Total token count *)
field blocks_for_rewards: BNum = BNum 2160
field rewards: Uint128 = Uint128 191203703703703
field token_holder: Map Uint256 Int256 = Emp Uint256 Int256

field crowd_sale: ByStr20 = zero_address

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure CheckMinLevel(token_id: Uint256)
  min_lvl <- min_lvl_for_claim;
  some_lvl <-& main.token_lvl[token_id];
  lvl = option_uint32 zero32 some_lvl;
  is_lt_min_lvl = builtin lt lvl min_lvl;

  match is_lt_min_lvl with
  | True =>
    err = CodeMinLvl;
    ThrowError err
  | False =>
  end
end


procedure CheckNumRange(number: Uint32)
  is_gte_zero = uint32_ge number zero32;
  is_lte_hundred = uint32_le number one_hundred32;
  is_within_range = andb is_gte_zero is_lte_hundred;

  match is_within_range with
  | True =>
  | False =>
    err = CodeInputOutOfRange;
    ThrowError err
  end
end

procedure OnlyAdmin()
  is_admin = builtin eq contract_owner _sender;

  match is_admin with
  | True =>
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure OnlyCrowdSale()
  address_crowd_sale <- crowd_sale;
  is_crowd_sale = builtin eq _sender address_crowd_sale;

  match is_crowd_sale with
  | True =>
  | False =>
    err = CodeNotCrowdSale;
    ThrowError err
  end
end

procedure OnlyTokenHolderNotExists(token_id: Uint256)
  is_already <- exists token_holder[token_id];

  match is_already with
  | False =>
  | True =>
    err = CodeTokenHolderAlreadyExists;
    ThrowError err
  end
end

procedure OnlyTokenOwner(token_id: Uint256)
  some_owner <-& main.token_owners[token_id];

  match some_owner with
  | Some owner =>
    is_owner = builtin eq owner _sender;

    match is_owner with
    | True =>
    | False =>
      err = CodeNotTokenOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

procedure CallTransfer(to: ByStr20, amount: Uint128)
  dmz_o <- dmz;
  msg_transfer = {
    _tag: "Transfer";
    _recipient: dmz_o;
    _amount: zero128;
    to: to;
    amount: amount
  };
  msgs = one_msg msg_transfer;
  send msgs
end


transition OnBeginReward(token_id: Uint256)
  OnlyCrowdSale;
  OnlyTokenHolderNotExists token_id;

  current_block <-& BLOCKNUMBER;
  blocks_amount <- blocks_for_rewards;

  new_holder = builtin bsub current_block blocks_amount;
  token_holder[token_id] := new_holder
end

transition Claim(token_id: Uint256)
  OnlyTokenOwner token_id;
  CheckMinLevel token_id;

  current_block <-& BLOCKNUMBER;
  rewards_amount <- rewards;
  some_acumulated <- token_holder[token_id];

  match some_acumulated with
  | Some acumulated =>
    block_number = builtin bsub current_block zeroBN;
    amount = get_claim_value block_number acumulated rewards_amount;

    token_holder[token_id] := block_number;
    CallTransfer _sender amount
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end


transition SetCrowdSale(address: ByStr20)
  OnlyAdmin;

  crowd_sale := address;

  e = {
    _eventname: "CrowdSaleChangedSuccess";
    address: address
  };
  event e
end

transition SetRewards(blocks: BNum, rewards_amount: Uint128)
  OnlyAdmin;

  blocks_for_rewards := blocks;
  rewards := rewards_amount;

  e = {
    _eventname: "RewardsChangedSuccess";
    blocks: blocks;
    rewards: rewards_amount
  };
  event e
end

transition ChangeMinLevel(value: Uint32)
  OnlyAdmin;
  CheckNumRange value;
  min_lvl_for_claim := value;

  e = {
    _eventname: "MinLevelChanged";
    min_lvl_for_claim: value
  };
  event e
end

(* @dev Updates the dmz contract address; used only by contract owner *)
transition UpdateDMZ(new_dmz: ByStr20)
  OnlyAdmin;
  dmz := new_dmz;
  e = {_eventname: "UpdateDMZ"; new_dmz: new_dmz};
  event e
end

(* callbacks *)
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
