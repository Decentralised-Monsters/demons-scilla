scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

library BondingCurvedDistributor

(* Error events *)
type Error =
  | CodeNotAuthorised
  | CodeNotMain

let customization = Uint256 500000000000
let exponent = Uint32 2
let zero256 = Uint256 0
let zero32 = Uint32 0
let one256 = Uint256 1
let one32 = Uint32 1

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotAuthorised    => Int32 -1
      | CodeNotMain          => Int32 -2
      end
    in
    { _exception : "Error"; code : result_code }

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_uint256 = @option_value Uint256
let option_uint32 = @option_value Uint32

let get_ids_list =
  fun (m : Uint32) =>
  fun (n : Uint32) =>
  fun (value : Uint256) =>
    let m_lt_n = builtin lt m n in
    match m_lt_n with
    | True =>
        let delta = builtin sub n m in
        let delta_nat = builtin to_nat delta in
        let nil = Nil {Uint256} in
        let acc_init = Pair {(List Uint256) Uint32} nil n in
        let step = fun (xs_n : Pair (List Uint256) Uint32) => fun (ignore : Nat) =>
          match xs_n with
          | Pair xs n =>
              let new_n = builtin sub n one32 in
              let some_new_value = builtin to_uint256 new_n in
              let new_value = option_uint256 zero256 some_new_value in
              let item = builtin sub value new_value in
              let new_xs = Cons {Uint256} item xs in
              Pair {(List Uint256) Uint32} new_xs new_n
          end in
        let fold = @nat_fold (Pair (List Uint256) Uint32) in
        let xs_m = fold step acc_init delta_nat in
        match xs_m with
        | Pair xs m => xs
        end
    | False => Nil {Uint256}
    end

let pool_balance =
  fun (s: Uint256) =>
    let new_n = builtin add exponent one32 in
    let some_new_n256 =  builtin to_uint256 new_n in
    let n256 = option_uint256 zero256 some_new_n256 in
    let m_div_new_n = builtin div customization n256 in
    let s_exp = builtin pow s new_n in
      builtin mul m_div_new_n s_exp

let calc_count =
  fun (amount: Uint128) =>
  fun (b: Uint256) =>
  fun (s: Uint256) =>
    let n = builtin add exponent one32 in
    let some_p = builtin to_uint256 amount in
    let p = option_uint256 zero256 some_p in
    let p_div_b = builtin div p b in
    let pb = builtin add p_div_b one256 in
    let f = builtin isqrt pb in
    let next = builtin isqrt f in
    let v = builtin mul s next in
    let value = builtin sub v one256 in
    let some_value =  builtin to_uint32 value in
      option_uint32 zero32 some_value

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract BondingCurvedDistributor
(
  demons: ByStr20
)

(* Mutable fields *)

(* Total token count *)
field total_reserve: Uint256 = zero256

field tokens_reserve: Map Uint256 String = Emp Uint256 String

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsMain()
  is_main_contract = builtin eq demons _sender;

  match is_main_contract with
  | True =>
  | False =>
    err = CodeNotMain;
    ThrowError err
  end
end

procedure Minting(to: ByStr20, token_uris_list: List String)
  msg_to_demons = {
    _tag: "BatchMint";
    _recipient: demons;
    _amount: Uint128 0;
    to: to;
    token_uris_list: token_uris_list
  };
  msgs = one_msg msg_to_demons;
  send msgs
end

procedure AddReserve(uri: String)
  count_reserve <- total_reserve;

  new_count_reserve = builtin add count_reserve one256;

  tokens_reserve[new_count_reserve] := uri;
  total_reserve := new_count_reserve;

  e = {
    _eventname: "AddedReserveToken";
    total_reserve: new_count_reserve;
    uri: uri
  };
  event e
end


transition AddReserveList(token_uris_list: List String)
  forall token_uris_list AddReserve
end

transition Buy()
  reserve <- total_reserve;
  b = pool_balance reserve;
  count = calc_count _amount b reserve;

  list = get_ids_list one32 count reserve;

  e = {
    _eventname: "Test";
    b: b;
    count: count;
    list: list
  };
  event e
end

(* callbacks *)
transition BatchMintCallBack(total_supply: Uint256)
end
(* callbacks *)