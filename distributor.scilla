scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils
library BondingCurvedDistributor

(* Error events *)
type Error =
  | CodeNotAuthorised
  | CodeNotMain

let precision = Uint256 10000000000
let zero256 = Uint256 0
let one32 = Uint32 1

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotAuthorised    => Int32 -1
      | CodeNotMain          => Int32 -2
      end
    in
    { _exception : "Error"; code : result_code }

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_uint256 = @option_value Uint256
let get_length = @list_length Uint256
let int_head = @list_head Int32
let merge_list = @list_append String

let curve_integral =
  fun (exponent: Uint32) =>
  fun (t: Uint256) =>
    let nexp = builtin add one32 exponent in
    let some_nexp256 = builtin to_uint256 nexp in
    let nexp256 = option_uint256 zero256 some_nexp256 in
    let t_exponent = builtin pow t nexp in
    let precision_nexp = builtin div precision nexp256 in
    let integral = builtin mul precision_nexp t_exponent in
      builtin div integral precision

let get_price =
  fun (count: Uint256) =>
  fun (reserve: Uint256) =>
  fun (total_supply: Uint256) =>
  fun (exponent: Uint32) =>
    let total = builtin add total_supply count in
    let value = builtin sub total reserve in
      curve_integral exponent value

let get_reward =
  fun (count: Uint256) =>
  fun (reserve: Uint256) =>
  fun (total_supply: Uint256) =>
  fun (exponent: Uint32) =>
    let amount = builtin sub total_supply count in
    let value = curve_integral exponent amount in
      builtin sub reserve value

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract BondingCurvedDistributor
(
  demons: ByStr20,
  exponent: Uint32
)

(* Mutable fields *)

(* Total token count *)
field total_reserve: Uint256 = zero256
field total: Uint256 = zero256

field tokens_list: List Uint256 = Nil {Uint256}

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsMain()
  is_main_contract = builtin eq demons _sender;

  match is_main_contract with
  | True =>
  | False =>
    err = CodeNotMain;
    ThrowError err
  end
end

procedure UpdateTotalSupply()
  msg_to_demons = {
    _tag: "TotalSupply";
    _recipient: demons;
    _amount: Uint128 0
  };
  msgs = one_msg msg_to_demons;
  send msgs
end

procedure UpdateTokenReserve()
  list <- tokens_list;

  length = get_length list;
  length = builtin to_uint256 length;
  length = option_uint256 zero256 length;

  total_reserve := length
end

procedure AddToken(id: Uint256)
  list <- tokens_list;
  new_list = Cons {Uint256} id list;
  tokens_list := new_list
end

procedure Minting(token_uris_list: List String)
  msg_to_demons = {
    _tag: "BatchMint";
    _recipient: demons;
    _amount: Uint128 0;
    to: _this_address;
    token_uris_list: token_uris_list
  };
  msgs = one_msg msg_to_demons;
  send msgs
end

transition BatchMint(token_uris_list: List String)
  Minting token_uris_list
end

transition Buy(count: Uint256)
  reserve <- total_reserve;
  total_supply <- total;

  price = get_price count reserve total_supply exponent;

  e = {
    _eventname: "test";
    price: price
  };
  event e
end

(* callbacks *)
transition TotalSupplyCallBack(total_supply: Uint256)
  IsMain;

  total := total_supply
end

transition RecipientAcceptBatchMint(ids: List Uint256, total_supply: Uint256)
  IsMain;
  forall ids AddToken;
  UpdateTokenReserve;

  total := total_supply
end

transition BatchMintCallBack()
end
(* callbacks *)